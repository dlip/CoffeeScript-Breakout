// Generated by CoffeeScript 1.12.2
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  $(function() {
    var Ball, Block, Blocks, Breakout, Collision, KeyboardInput, MouseInput, Paddle, Screen, Sprite, Timer, Vector, game;
    Screen = (function() {
      function Screen(width1, height1) {
        this.width = width1;
        this.height = height1;
        this.canvas = $('#breakout')[0];
        this.ctx = this.canvas.getContext("2d");
        this.ctx.onclick = function() {
          return window.location = canvas.toDataURL('image/png');
        };
      }

      Screen.prototype.clear = function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.width, this.height);
        return this.ctx.fillStyle = '#FFFFFF';
      };

      Screen.prototype.circle = function(x, y, r) {
        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI * 2, true);
        this.ctx.closePath();
        return this.ctx.fill();
      };

      Screen.prototype.rect = function(x, y, w, h, color) {
        this.ctx.fillStyle = '#000000';
        if (color != null) {
          this.ctx.fillStyle = color;
        }
        this.ctx.beginPath();
        this.ctx.rect(x, y, w, h);
        this.ctx.closePath();
        return this.ctx.fill();
      };

      return Screen;

    })();
    MouseInput = (function() {
      function MouseInput() {
        this.pos = new Vector(0, 0);
        $(document).mousemove((function(_this) {
          return function(event) {
            return _this.onMouseMove(event);
          };
        })(this));
      }

      MouseInput.prototype.onMouseMove = function(event) {
        this.pos.x = event.pageX;
        return this.pos.y = event.pageY;
      };

      return MouseInput;

    })();
    KeyboardInput = (function() {
      function KeyboardInput() {
        this.left = false;
        this.right = false;
        $(document).keydown((function(_this) {
          return function(event) {
            return _this.onKeyDown(event);
          };
        })(this));
        $(document).keyup((function(_this) {
          return function(event) {
            return _this.onKeyUp(event);
          };
        })(this));
      }

      KeyboardInput.prototype.onKeyDown = function(event) {
        switch (event.keyCode) {
          case 39:
          case 73:
            return this.right = true;
          case 37:
          case 78:
            return this.left = true;
        }
      };

      KeyboardInput.prototype.onKeyUp = function(event) {
        switch (event.keyCode) {
          case 39:
          case 73:
            return this.right = false;
          case 37:
          case 78:
            return this.left = false;
        }
      };

      return KeyboardInput;

    })();
    Sprite = (function() {
      function Sprite(screen) {
        this.screen = screen;
      }

      Sprite.prototype.update = function(time) {};

      Sprite.prototype.draw = function() {};

      return Sprite;

    })();
    Vector = (function() {
      function Vector(x1, y1) {
        this.x = x1;
        this.y = y1;
      }

      return Vector;

    })();
    Block = (function(superClass) {
      extend(Block, superClass);

      function Block(screen, x, y, width, height, color1) {
        this.screen = screen;
        this.color = color1;
        this.pos = new Vector(x, y);
        this.size = new Vector(width, height);
        this.destroyed = false;
      }

      Block.prototype.draw = function() {
        if (this.destroyed) {
          return;
        }
        return this.screen.rect(this.pos.x, this.pos.y, this.size.x, this.size.y, this.color);
      };

      return Block;

    })(Sprite);
    Blocks = (function(superClass) {
      extend(Blocks, superClass);

      function Blocks(screen) {
        var i, j, ref, ref1, rowcolors, x, y;
        this.screen = screen;
        this.rows = 5;
        this.cols = 5;
        this.blockWidth = (this.screen.width / this.cols) - 1;
        this.blockHeight = 15;
        this.blockPadding = 1;
        rowcolors = ["#FF1C0A", "#FFFD0A", "#00A308", "#0008DB", "#EB0093"];
        this.blocks = new Array(this.rows);
        for (x = i = 0, ref = this.rows; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
          this.blocks[x] = new Array(this.cols);
          for (y = j = 0, ref1 = this.cols; 0 <= ref1 ? j < ref1 : j > ref1; y = 0 <= ref1 ? ++j : --j) {
            this.blocks[x][y] = new Block(this.screen, x * (this.blockWidth + this.blockPadding) + this.blockPadding, y * (this.blockHeight + this.blockPadding) + this.blockPadding, this.blockWidth, this.blockHeight, rowcolors[y]);
          }
        }
      }

      Blocks.prototype.draw = function() {
        var i, ref, results, x, y;
        results = [];
        for (x = i = 0, ref = this.rows; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
          results.push((function() {
            var j, ref1, results1;
            results1 = [];
            for (y = j = 0, ref1 = this.cols; 0 <= ref1 ? j < ref1 : j > ref1; y = 0 <= ref1 ? ++j : --j) {
              results1.push(this.blocks[x][y].draw());
            }
            return results1;
          }).call(this));
        }
        return results;
      };

      return Blocks;

    })(Sprite);
    Ball = (function(superClass) {
      extend(Ball, superClass);

      function Ball(screen, paddle1, blocks1) {
        this.screen = screen;
        this.paddle = paddle1;
        this.blocks = blocks1;
        this.size = new Vector(10, 10);
        this.vel = new Vector(0, 190);
        this.reset();
      }

      Ball.prototype.reset = function() {
        this.pos = new Vector(this.paddle.pos.x + this.paddle.size.x / 2, this.paddle.pos.y - 190);
        if (this.vel.y < 0) {
          return this.vel.y *= -1;
        }
      };

      Ball.prototype.isOut = function() {
        return this.pos.y - this.size.y > this.screen.height;
      };

      Ball.prototype.update = function(time) {
        var ballBottom, ballLeft, ballRight, ballTop, block, contact, i, j, multiplier, nextOffset, paddleTop, ref, ref1, x, y;
        nextOffset = new Vector(0, 0);
        nextOffset.x = this.vel.x * time;
        nextOffset.y = this.vel.y * time;
        ballBottom = new Vector(this.pos.x, this.pos.y + this.size.y);
        ballTop = new Vector(this.pos.x, this.pos.y - this.size.y);
        ballLeft = new Vector(this.pos.x - this.size.x, this.pos.y);
        ballRight = new Vector(this.pos.x + this.size.x, this.pos.y);
        if (ballLeft.x < 0 && this.vel.x < 0) {
          this.vel.x *= -1;
        } else if (ballRight.x > this.screen.width && this.vel.x > 0) {
          this.vel.x *= -1;
        } else if (ballTop.y < 0 && this.vel.y < 0) {
          this.vel.y *= -1;
        }
        paddleTop = this.screen.height - this.paddle.size.y;
        if (ballBottom.y < paddleTop && ballBottom.y + nextOffset.y > paddleTop) {
          if (this.hasCollidedWithPaddle() && this.vel.y > 0) {
            multiplier = (this.pos.x - (this.paddle.pos.x + this.paddle.size.x / 2)) / (this.paddle.size.x / 2);
            this.vel.x = 150 * multiplier;
            this.vel.y *= -1;
          }
        }
        for (x = i = 0, ref = this.blocks.rows; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
          for (y = j = 0, ref1 = this.blocks.cols; 0 <= ref1 ? j < ref1 : j > ref1; y = 0 <= ref1 ? ++j : --j) {
            block = this.blocks.blocks[x][y];
            if (block.destroyed) {
              continue;
            }
            contact = false;
            if (Collision.pointInRect(ballTop, block.pos, block.size) && this.vel.y < 0) {
              contact = true;
              this.vel.y *= -1;
            }
            if (Collision.pointInRect(ballBottom, block.pos, block.size) && this.vel.y > 0) {
              contact = true;
              this.vel.y *= -1;
            }
            if (Collision.pointInRect(ballLeft, block.pos, block.size) && this.vel.x < 0) {
              contact = true;
              this.vel.x *= -1;
            }
            if (Collision.pointInRect(ballRight, block.pos, block.size) && this.vel.x > 0) {
              contact = true;
              this.vel.x *= -1;
            }
            if (contact) {
              block.destroyed = true;
            }
          }
        }
        this.pos.x += nextOffset.x;
        return this.pos.y += nextOffset.y;
      };

      Ball.prototype.hasCollidedWithPaddle = function() {
        if (this.pos.x + this.size.x > this.paddle.pos.x && this.pos.x - this.size.x < this.paddle.pos.x + this.paddle.size.x) {
          return true;
        }
        return false;
      };

      Ball.prototype.draw = function() {
        return this.screen.circle(this.pos.x, this.pos.y, 10);
      };

      return Ball;

    })(Sprite);
    Collision = (function() {
      function Collision() {}

      Collision.pointInRect = function(point, rectPos, rectSize) {
        if (point.x > rectPos.x && point.x < rectPos.x + rectSize.x && point.y > rectPos.y && point.y < rectPos.y + rectSize.y) {
          return true;
        }
        return false;
      };

      return Collision;

    })();
    Paddle = (function(superClass) {
      extend(Paddle, superClass);

      function Paddle(screen, mouseInput, keyboardInput) {
        this.screen = screen;
        this.mouseInput = mouseInput;
        this.keyboardInput = keyboardInput;
        this.size = new Vector(75, 10);
        this.pos = new Vector((this.screen.width / 2) - (this.size.x / 2), this.screen.height - 10);
        this.lastMousePos = this.mouseInput.pos.x;
        this.color = '#444444';
      }

      Paddle.prototype.update = function(time) {
        if (this.lastMousePos !== this.mouseInput.pos.x) {
          this.pos.x = this.mouseInput.pos.x - this.size.x / 2;
        }
        if (this.keyboardInput.left === true) {
          this.pos.x -= 600 * time;
        }
        if (this.keyboardInput.right === true) {
          this.pos.x += 600 * time;
        }
        if (this.pos.x < 0) {
          this.pos.x = 0;
        }
        if (this.pos.x + this.size.x > this.screen.width) {
          this.pos.x = this.screen.width - this.size.x;
        }
        return this.lastMousePos = this.mouseInput.pos.x;
      };

      Paddle.prototype.draw = function() {
        return this.screen.rect(this.pos.x, this.pos.y, this.size.x, this.size.y, this.color);
      };

      return Paddle;

    })(Sprite);
    Timer = (function() {
      function Timer() {}

      Timer.prototype.start = function() {
        this.startDate = new Date();
        return this.lastDate = new Date();
      };

      Timer.prototype.advance = function() {
        var now;
        now = new Date;
        this.diffInMilliseconds = now - this.lastDate;
        this.diff = this.diffInMilliseconds / 1000;
        this.timeInMilliseconds += now - this.startDate;
        this.time = this.timeInMilliseconds / 1000;
        return this.lastDate = new Date();
      };

      return Timer;

    })();
    Breakout = (function() {
      function Breakout() {
        var blocks, paddle;
        this.paused = false;
        this.screen = new Screen(300, 300);
        this.timer = new Timer;
        this.mouseInput = new MouseInput;
        this.keyboardInput = new KeyboardInput;
        this.sprites = [];
        paddle = new Paddle(this.screen, this.mouseInput, this.keyboardInput);
        this.sprites.push(paddle);
        blocks = new Blocks(this.screen);
        this.sprites.push(blocks);
        this.ball = new Ball(this.screen, paddle, blocks);
        this.sprites.push(this.ball);
      }

      Breakout.prototype.run = function() {
        this.timer.start();
        return setInterval(((function(_this) {
          return function() {
            return _this.update();
          };
        })(this)), 1000 / 50);
      };

      Breakout.prototype.update = function() {
        var i, len, ref, results, sprite;
        this.timer.advance();
        if (this.paused) {
          return;
        }
        if (this.ball.isOut()) {
          this.ball.reset();
        }
        this.screen.clear();
        ref = this.sprites;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          sprite = ref[i];
          sprite.update(this.timer.diff);
          results.push(sprite.draw());
        }
        return results;
      };

      return Breakout;

    })();
    game = new Breakout;
    return game.run();
  });

}).call(this);
